#!/usr/bin/python3
import sys
import smaract.ctl as ctl

# SmarAct MCS2 programming example: IO-Module
#
# This programming example shows how to configure a SmarAct MCS2 IO Module
#
# For a full command reference see the MCS2 Programmers Guide.

def assert_lib_compatibility():
    """
    Checks that the major version numbers of the Python API and the
    loaded shared library are the same to avoid errors due to 
    incompatibilities.
    Raises a RuntimeError if the major version numbers are different.
    """
    vapi = ctl.api_version
    vlib = [int(i) for i in ctl.GetFullVersionString().split('.')]
    if vapi[0] != vlib[0]:
        raise RuntimeError("Incompatible SmarActCTL python api and library version.")

def waitForEvent():
    """ Wait for events generated by the connected device """
    # The wait for event function blocks until an event was received or the timeout elapsed.
    # In case of timeout, a "ctl.Error" exception is raised containing the "TIMEOUT" error.
    # If the "timeout" parameter is set to "ctl.INFINITE" the call blocks until an event is received.
    # This can be useful in case the WaitForEvent function runs in a separate thread.
    # For simplicity, this is not shown here thus we set a timeout of 3 seconds.
    timeout = 10000 # in ms
    done = False
    while (not done):
        try:
            event = ctl.WaitForEvent(d_handle, timeout)
            # we use a timeout of 10s, so the function call returns
            # if an event was received or at the latest after 10 seconds
            if event.type == ctl.EventType.EMERGENCY_STOP_TRIGGERED:
                print("MCS2 received event: {}".format(ctl.GetEventInfo(event)))
                done = True
                break
            else:
                # The code should be prepared to handle unexpected events beside the expected ones.
                print("MCS2 received unexpected event: {}".format(ctl.GetEventInfo(event)))
        except ctl.Error as e:
            if e.code == ctl.ErrorCode.TIMEOUT:
                print("MCS2 wait for event timed out after {} seconds.\nStop positioner.".format(timeout/1000))
                ctl.Stop(d_handle, channel)
            else:
                print("MCS2 {}".format(ctl.GetResultInfo(e.code)))
            return

print("*******************************************************")
print("*  SmarAct MCS2 Programming Example (IO Module)       *")
print("*******************************************************")

# Read the version of the library
# Note: this is the only function that does not require the library to be initialized.
version = ctl.GetFullVersionString()
print("SmarActCTL library version: '{}'.".format(version))
assert_lib_compatibility()

# Find available MCS2 devices
try:
    buffer = ctl.FindDevices()
    if len(buffer) == 0:
        print("MCS2 no devices found.")
        sys.exit(1)
    locators = buffer.split("\n")
    for locator in locators:
        print("MCS2 available devices: {}".format(locator))
except:
    print("MCS2 failed to find devices. Exit.")
    input()
    sys.exit(1)

d_handle = None
channel = 0
try:
    # Open the first MCS2 device from the list
    d_handle = ctl.Open(locators[0])
    print("MCS2 opened {}.".format(locators[0]))

    # Enable the amplifier
    ctl.SetProperty_i32(d_handle, channel, ctl.Property.AMPLIFIER_ENABLED, ctl.TRUE)

    # Please note:
    # The MCS2 must be equipped with an I/O module in order to execute the following examples.
    # If no I/O module is available the properties return a ctl.ErrorCode.NO_IOM_PRESENT error.

    # Start the examples
    for sequ in range(2):
        ret = '#'
        if sequ == 0:
            ret = '#'
            print("*******************************************************")
            print("First sequence:")
            print("- Digital input triggers an emergency stop -")
            print("-> press key to [c]ontinue or [s]kip.")
            while not (ret == 'c' or ret == 's'):
                ret = input()
            if ret == 'c':
                # Device input trigger -> emergency stop:
                # We need to set the following device properties to configure the emergency stop input trigger:
                # 1. the emergency stop mode (behavior of the emergency stop function)
                # 2. the device input trigger mode (connect digital device input to the emergency stop function)
                # 3. the polarity of the device input signal (trigger emergency stop on rising / falling edge of the digital input signal)
                # Afterwards we start a slow, long movement which can be aborted by applying a digital signal to the input.
                # The trigger signal must be fed into the digital device input of an I/O module to stop all channels.

                # Note that the device input trigger is dedicated to the whole device and not to a specific channel.
                # Channel-based emergency stop is available by using the general-purpose digital inputs of an I/O module.
                # (Not the scope of this example.)
                print("Set emergency stop mode to normal mode.")
                ctl.SetProperty_i32(d_handle, 0, ctl.Property.EMERGENCY_STOP_MODE, ctl.EmergencyStopMode.NORMAL)
                print("Set trigger condition to rising edge.")
                ctl.SetProperty_i32(d_handle, 0, ctl.Property.DEV_INPUT_TRIG_CONDITION, ctl.TriggerCondition.RISING)
                print("Configure input trigger mode to emergency stop mode.")
                ctl.SetProperty_i32(d_handle, 0, ctl.Property.DEV_INPUT_TRIG_MODE, ctl.DeviceInputTriggerMode.EMERGENCY_STOP)

                print("Start movement with velocity: 1um/s, distance: 2mm.")
                # Set move mode to relative movement
                ctl.SetProperty_i32(d_handle, channel, ctl.Property.MOVE_MODE, ctl.MoveMode.CL_RELATIVE)
                # Set move velocity to 10um/s
                ctl.SetProperty_i64(d_handle, channel, ctl.Property.MOVE_VELOCITY, 10000000)
                # Set move acceleration to 10 mm/s2.
                ctl.SetProperty_i64(d_handle, channel, ctl.Property.MOVE_ACCELERATION, 10000000000)
                ctl.Move(d_handle, channel, 2000000000)
                
                # Wait for the trigger
                print("Now waiting for the emergency stop to be triggered...")
                waitForEvent()
                # Disable the input trigger
                ctl.SetProperty_i32(d_handle, 0, ctl.Property.DEV_INPUT_TRIG_MODE, ctl.DeviceInputTriggerMode.DISABLED)
                
            else:
                print("Skipping sequence.")
        else:
            ret = '#'
            print("*******************************************************")
            print("Second sequence:")
            print("- Position compare output trigger -")
            print("-> press key to [c]ontinue or [s]kip.")
            while not (ret == 'c' or ret == 's'):
                ret = input()
            if ret == 'c':
                # Position compare output trigger:
                # We need to set the following properties to configure the position compare output trigger for channel 0:
                # 1. the channel properties specific to the position compare output trigger (start threshold, increment, direction)
                # 2. the channel output trigger mode (behavior of the output trigger function)
                # 4. the general channel output trigger properties, which are not specific to the position compare function
                #    (output trigger polarity, pulse width of the digital output signal)
                # 5. IO module settings (output signal voltage, output driver enabled)

                # Note that the output trigger is dedicated to a specific channel (channel 0 in this example)
                # while the IO module settings are global for the whole IO module (all 3 channels of the module).
                # The output trigger mode should be the last property to set after all previous configuration was set.

                # Afterwards we start a long movement.
                # The channel will generate a 1 us pulse (0.5 us high, 0.5 us low) once the position of channel 0 passed
                # 25um in rising direction. Furthermore every 50 um consecutive pulses are output.

                # Since the direction is configured to "forward", trigger pulses are only generated in this movement direction.
                # Lets say, the positioner passed the starting threshold of 25um -> a pulse is output.
                # Now the threshold is incremented internally by the configured increment of 50um -> the next trigger pulse will be
                # output once the positioner passed the position of 75um, and so on.
                # Set current position to zero
                ctl.SetProperty_i64(d_handle, channel, ctl.Property.POSITION, 0)
                # Set start position to 25um
                ctl.SetProperty_i64(d_handle, channel, ctl.Property.CH_POS_COMP_START_THRESHOLD, 25000000)
                # Set position increment to 50um
                ctl.SetProperty_i64(d_handle, channel, ctl.Property.CH_POS_COMP_INCREMENT, 50000000)
                # Set direction to forward
                ctl.SetProperty_i32(d_handle, channel, ctl.Property.CH_POS_COMP_DIRECTION, ctl.FORWARD_DIRECTION)
                # disable limits
                ctl.SetProperty_i64(d_handle, channel, ctl.Property.CH_POS_COMP_LIMIT_MIN, 0)
                ctl.SetProperty_i64(d_handle, channel, ctl.Property.CH_POS_COMP_LIMIT_MAX, 0)
                # Set output polarity to active high - ____|^|_________  (low while idle, high when the trigger occurs)
                ctl.SetProperty_i32(d_handle, channel, ctl.Property.CH_OUTPUT_TRIG_POLARITY, ctl.TriggerPolarity.ACTIVE_HIGH)
                # Set pulse width to be 0.5 us high and 0.5 us low.
                ctl.SetProperty_i32(d_handle, channel, ctl.Property.CH_OUTPUT_TRIG_PULSE_WIDTH, 1000)
                print("Set output trigger mode for channel {} to position compare.".format(channel))
                ctl.SetProperty_i32(d_handle, channel, ctl.Property.CH_OUTPUT_TRIG_MODE, ctl.ChannelOutputTriggerMode.POSITION_COMPARE)
                print("Configure the I/O module: (3.3V output voltage, driver enabled)")
                # Set output driver voltage level to 3.3V.
                ctl.SetProperty_i32(d_handle, 0, ctl.Property.IO_MODULE_VOLTAGE, ctl.IOModuleVoltage.VOLTAGE_3V3)
                # Enable the digital output driver circuit of the I/O module.
                ctl.SetProperty_i32(d_handle, 0, ctl.Property.IO_MODULE_OPTIONS, ctl.IOModuleOption.DIGITAL_OUTPUT_ENABLED)
                print("Start movement with velocity: 10um/s, distance: 2mm.")
                # Set move mode to relative movement
                ctl.SetProperty_i32(d_handle, channel, ctl.Property.MOVE_MODE, ctl.MoveMode.CL_RELATIVE)
                # Set move velocity to 50um/s
                ctl.SetProperty_i64(d_handle, channel, ctl.Property.MOVE_VELOCITY, 50000000)
                # Set move acceleration to 10 mm/s2.
                ctl.SetProperty_i64(d_handle, channel, ctl.Property.MOVE_ACCELERATION, 10000000000)
                ctl.Move(d_handle, channel, 2000000000, 0)
                print("Starting at 25um, every 50um consecutive pulses are output\non the channel {} fast digital output...".format(channel))
                print("Press any key to stop the movement.")
                input()
                # Stop the movement and set output trigger to constant
                ctl.Stop(d_handle, channel)
                ctl.SetProperty_i32(d_handle, channel, ctl.Property.CH_OUTPUT_TRIG_MODE, ctl.ChannelOutputTriggerMode.CONSTANT)
                # Disable the output driver circuit of the I/O module.
                ctl.SetProperty_i32(d_handle, 0, ctl.Property.IO_MODULE_OPTIONS, 0)
            else:
                print("Skipping sequence.")

except ctl.Error as e:
    # Passing an error code to "GetResultInfo" returns a human readable string
    # specifying the error.
    print("MCS2 {}: {}, error: {} (0x{:04X}) in line: {}."
          .format(e.func, ctl.GetResultInfo(e.code), ctl.ErrorCode(e.code).name, e.code, (sys.exc_info()[-1].tb_lineno)))

except Exception as ex:
    print("Unexpected error: {}, {} in line: {}".format(ex, type(ex), (sys.exc_info()[-1].tb_lineno)))
    raise

finally:
    # Before closing the program the connection to the device must be closed by calling "Close".
    if d_handle != None:
        ctl.Close(d_handle)
    print("MCS2 close.")
    print("*******************************************************")
    print("Done. Press return to exit.")
    input()
