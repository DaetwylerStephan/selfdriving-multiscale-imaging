#!/usr/bin/python3
import sys
from threading import Event, Thread
import smaract.ctl as ctl

# SmarAct MCS2 programming example: Streaming
#
# This programming example shows the MCS2 trajectory streaming.
# For a full command reference see the MCS2 Programmers Guide.

NUMBER_OF_STREAMING_CHANNELS = 2
MAX_NUMBER_OF_FRAMES = 1024
STREAM_FILE_NAME = "streamPoses.csv"

# status events, used for inter-thread communication
# This is one of the simplest mechanisms for communication between threads: one thread signals an event and other threads wait for it.
# An event object manages an internal flag that can be set to true with the set() method and reset to false with the clear() method.
# The wait() method blocks until the flag is true.
stream_done = Event()
stream_abort = Event()

def assert_lib_compatibility():
    """
    Checks that the major version numbers of the Python API and the
    loaded shared library are the same to avoid errors due to 
    incompatibilities.
    Raises a RuntimeError if the major version numbers are different.
    """
    vapi = ctl.api_version
    vlib = [int(i) for i in ctl.GetFullVersionString().split('.')]
    if vapi[0] != vlib[0]:
        raise RuntimeError("Incompatible SmarActCTL python api and library version.")

def waitForEvent():
    """Wait for events generated by the connected device"""
    while True:
        try:
            event = ctl.WaitForEvent(d_handle, ctl.INFINITE)
            # The "type" field specifies the event.
            # The "idx" field holds the channel where the event came from.
            # The "i32" data field gives additional information about the event, e.g. error code.
            # Passing the event to GetEventInfo" returns a human readable string
            # specifying the event.
            if event.type == ctl.EventType.STREAM_FINISHED:
                print("MCS2 {}".format(ctl.GetEventInfo(event)))
                if ctl.EventParameter.PARAM_RESULT(event.i32) == ctl.ErrorCode.NONE:
                    # All streaming frames were processed, stream finished.
                    stream_done.set()
                elif ctl.EventParameter.PARAM_RESULT(event.i32) == ctl.ErrorCode.ABORTED:
                    # Stream was canceled by the user.
                    print("MCS2 stream aborted by user")
                    stream_done.set()
                    stream_abort.set()
                else:
                    # Stream was canceled by device.
                    # Note: The event parameter now holds the error code as well as the channel index responsible for the failure
                    print("MCS2 stream aborted by device: {}".format(ctl.ErrorCode(ctl.EventParameter.PARAM_RESULT(event.i32)).name))
                    stream_done.set()
                    stream_abort.set()
            elif event.type == ctl.EventType.STREAM_READY or event.type == ctl.EventType.STREAM_TRIGGERED:
                # These events are mainly useful when the STREAM_TRIGGER_MODE_EXTERNAL_ONCE trigger mode is used.
                # A STREAM_READY event is generated to indicate that the stream is ready to be triggered
                # by the external trigger. In this armed state the device waits for the trigger to occur and then generates a
                # STREAM_TRIGGERED event.
                # This example uses the STREAM_TRIGGER_MODE_DIRECT trigger mode, thus we don't care about this events here.
                pass
            else:
                # The code should be prepared to handle unexpected events beside the expected ones.
                print("MCS2 received event: {}".format(ctl.GetEventInfo(event)))

        except ctl.Error as e:
            if e.code == ctl.ErrorCode.CANCELED:
                # we use "INFINITE" timeout, so the function call will return only when canceled by the "Cancel" function
                print("MCS2 canceled wait for event")
            else:
                print("MCS2 {}".format(ctl.GetResultInfo(e.code)))
            return

print("*******************************************************")
print("*  SmarAct MCS2 Programming Example (Streaming)       *")
print("*******************************************************")
# Read the version of the library
# Note: this is the only function that does not require the library to be initialized.
version = ctl.GetFullVersionString()
print("SmarActCTL library version: '{}'.".format(version))
assert_lib_compatibility()

# Open csv file and fill stream buffer
# The file format must be:
# - one frame per line
# - four numeric values separated by commas
# <channelA>,<positionA>,<channelB>,<positionB>
# ...
# - up to 1024 lines
# - first line is ignored (title)
try:
    with open(STREAM_FILE_NAME) as file:
        # Consume the head line
        next(file)
        no_of_frames = 0
        valid = True
        stream_buffer = []
        for line in file:
            line = line.strip()
            # Ignore blank lines
            if not line:
                continue
            ch_A, pos_A, ch_B, pos_B = line.split(",")
            # Basic valid checks
            if (int(ch_A) < 0) or (int(ch_B) < 0) or (int(ch_A) > int(ch_B)):
                # Channels must be in ascending order
                valid = False
                break
            if no_of_frames >= MAX_NUMBER_OF_FRAMES:
                break
            # Write frames to buffer
            frame = [int(ch_A), int(pos_A), int(ch_B), int(pos_B)]
            stream_buffer.append(frame)
            no_of_frames += 1
except Exception as e:
    print("Failed to open pose file {}: {}, abort.".format(STREAM_FILE_NAME, e))
    input()
    sys.exit(1)

if (not valid):
    print("File format invalid.")
    input()
    sys.exit(1)
else:
    print("Read {} stream frames from file {}".format(no_of_frames, STREAM_FILE_NAME))

d_handle = None
try:
    # Open the first USB MCS2 found.
    locator = "network:sn:MCS2-00000382"
    d_handle = ctl.Open(locator)
    print("MCS2 opened {}.".format(locator))
    print("*******************************************************")
    print("-> Press return to start position streaming.")
    input()
    # Spawn a thread to receive events from the controller.
    event_handle_thread = Thread(target=waitForEvent)
    event_handle_thread.start()

    # Set position zero, enable amplifier
    # Sensor power mode: enabled (disable power save, which is not allowed with position streaming)
    for channel in range(NUMBER_OF_STREAMING_CHANNELS):
        ctl.SetProperty_i64(d_handle, channel, ctl.Property.POSITION, 0)
        ctl.SetProperty_i32(d_handle, channel, ctl.Property.SENSOR_POWER_MODE, ctl.SensorPowerMode.ENABLED)
        ctl.SetProperty_i32(d_handle, channel, ctl.Property.AMPLIFIER_ENABLED, ctl.TRUE)

    # Configure stream (optional)
    # Note: the stream rate must be a whole-number multiplier of the external sync rate.
    # Set external sync rate to 100Hz (only active when using trigger mode STREAM_TRIGGER_MODE_EXTERNAL_SYNC)
    ctl.SetProperty_i32(d_handle, 0, ctl.Property.STREAM_EXT_SYNC_RATE, 100)
    # Set stream base rate to 1kHz
    ctl.SetProperty_i32(d_handle, 0, ctl.Property.STREAM_BASE_RATE, 1000)
    # Prepare for streaming, select desired trigger mode
    # (using STREAM_TRIGGER_MODE_DIRECT starts the stream as soon as enough frames were sent to the device)
    s_handle = ctl.OpenStream(d_handle, ctl.StreamTriggerMode.DIRECT)
    # Send all frames in a loop
    # Note: the "AbortStream" function could be used to abort a running stream programmatically.
    for frame_idx in range(no_of_frames):
        # The "waitForEvent" thread received an "abort" event.
        if stream_abort.isSet():
            break
        # Make list from stream data, each frame contains all
        # target positions for all channels that participate in the trajectory.
        # The frame data list must have the structure:
        # <chA>,<posA,<chB>,<posB>
        frame = stream_buffer[frame_idx]
        ctl.StreamFrame(d_handle, s_handle, frame)

    # All frames sent, close stream
    ctl.CloseStream(d_handle, s_handle)
    # Wait for the "stream done" event.
    stream_done.wait()
    # Cancel waiting for events.
    ctl.Cancel(d_handle)
    # Wait for the "waitForEvent" thread to terminate.
    event_handle_thread.join()

except ctl.Error as e:
    # Passing an error code to "GetResultInfo" returns a human readable string
    # specifying the error.
    print("MCS2 {}: {}, error: {} (0x{:04X}) in line: {}."
          .format(e.func, ctl.GetResultInfo(e.code), ctl.ErrorCode(e.code).name, e.code, (sys.exc_info()[-1].tb_lineno)))

except Exception as ex:
    print("Unexpected error: {}, {} in line: {}".format(ex, type(ex), (sys.exc_info()[-1].tb_lineno)))
    raise

finally:
    # Before closing the program the connection to the device must be closed by calling "Close".
    if d_handle != None:
        ctl.Close(d_handle)
    print("MCS2 close.")
    print("*******************************************************")
    print("Done. Press return to exit.")
    input()
